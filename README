NAME
    DBIx::Class::Schema::Loader - Dynamic definition of a
    DBIx::Class::Schema

SYNOPSIS
      package My::Schema;
      use base qw/DBIx::Class::Schema::Loader/;

      __PACKAGE__->loader_options(
          relationships           => 1,
          constraint              => '^foo.*',
          # debug                 => 1,
      );

      # in seperate application code ...

      use My::Schema;

      my $schema1 = My::Schema->connect( $dsn, $user, $password, $attrs);
      # -or-
      my $schema1 = "My::Schema"; $schema1->connection(as above);
    =head1 DESCRIPTION 
    DBIx::Class::Schema::Loader automates the definition of a
    L<DBIx::Class::Schema> by scanning database table definitions and
    setting up the columns and primary keys.

    DBIx::Class::Schema::Loader currently supports DBI for MySQL, Postgres,
    SQLite and DB2.

    See DBIx::Class::Schema::Loader::DBI::Writing for notes on writing your
    own vendor-specific subclass for an unsupported DBD driver.

    This module requires DBIx::Class 0.06 or later, and obsoletes the older
    DBIx::Class::Loader.

    This module is designed more to get you up and running quickly against
    an existing database, or to be effective for simple situations, rather
    than to be what you use in the long term for a complex database/project.

    That being said, transitioning your code from a Schema generated by this
    module to one that doesn't use this module should be straightforward and
    painless (as long as you're not using any methods that are now
    deprecated in this document), so don't shy away from it just for fears
    of the transition down the road.

METHODS
  loader_options
    Example in Synopsis above demonstrates a few common arguments. For
    detailed information on all of the arguments, most of which are only
    useful in fairly complex scenarios, see the
    DBIx::Class::Schema::Loader::Base documentation.

    This method is *required*, for backwards compatibility reasons. If you
    do not wish to change any options, just call it with an empty argument
    list during schema class initialization.

  connection
    See DBIx::Class::Schema. Our local override here is to hook in the main
    functionality of the loader, which occurs at the time the connection is
    specified for a given schema class/object.

  clone
    See DBIx::Class::Schema. Our local override here is to make sure cloned
    schemas can still be loaded at runtime by copying and altering a few
    things here.

  dump_to_dir
    Argument: directory name.

    Calling this as a class method on either DBIx::Class::Schema::Loader or
    any derived schema class will cause all affected schemas to dump manual
    versions of themselves to the named directory when they are loaded. In
    order to be effective, this must be set before defining a connection on
    this schema class or any derived object (as the loading happens at
    connection time, and only once per class).

    See "dump_directory" in DBIx::Class::Schema::Loader::Base for more
    details on the dumping mechanism.

    This can also be set at module import time via the import option
    "dump_to_dir:/foo/bar" to DBIx::Class::Schema::Loader, where "/foo/bar"
    is the target directory.

    Examples:

        # My::Schema isa DBIx::Class::Schema::Loader, and has connection info
        #   hardcoded in the class itself:
        perl -MDBIx::Class::Schema::Loader=dump_to_dir:/foo/bar -MMy::Schema -e1

        # Same, but no hard-coded connection, so we must provide one:
        perl -MDBIx::Class::Schema::Loader=dump_to_dir:/foo/bar -MMy::Schema -e 'My::Schema->connection("dbi:Pg:dbname=foo", ...)'

        # Or as a class method, as long as you get it done *before* defining a
        #  connection on this schema class or any derived object:
        use My::Schema;
        My::Schema->dump_to_dir('/foo/bar');
        My::Schema->connection(........);

        # Or as a class method on the DBIx::Class::Schema::Loader itself, which affects all
        #   derived schemas
        use My::Schema;
        use My::OtherSchema;
        DBIx::Class::Schema::Loader->dump_to_dir('/foo/bar');
        My::Schema->connection(.......);
        My::OtherSchema->connection(.......);

        # Another alternative to the above:
        use DBIx::Class::Schema::Loader qw| dump_to_dir:/foo/bar |;
        use My::Schema;
        use My::OtherSchema;
        My::Schema->connection(.......);
        My::OtherSchema->connection(.......);

  make_schema_at
    This simple function allows one to create a Loader-based schema
    in-memory on the fly without any on-disk class files of any kind. When
    used with the "dump_directory" option, you can use this to generate a
    rought draft manual schema from a dsn without the intermediate step of
    creating a physical Loader-based schema class.

    This function can be exported/imported by the normal means, as
    illustrated in these Examples:

        # Simple example...
        use DBIx::Class::Schema::Loader qw/ make_schema_at /;
        make_schema_at(
            'New::Schema::Name',
            { relationships => 1, debug => 1 },
            [ 'dbi:Pg:dbname="foo"','postgres' ],
        );

        # Complex: dump loaded schema to disk, all from the commandline:
        perl -MDBIx::Class::Schema::Loader=make_schema_at,dump_to_dir:./lib -e 'make_schema_at("New::Schema::Name", { relationships => 1 }, [ 'dbi:Pg:dbname="foo"','postgres' ])'

        # Same, but inside a script, and using a different way to specify the
        # dump directory:
        use DBIx::Class::Schema::Loader qw/ make_schema_at /;
        make_schema_at(
            'New::Schema::Name',
            { relationships => 1, debug => 1, dump_directory => './lib' },
            [ 'dbi:Pg:dbname="foo"','postgres' ],
        );

EXAMPLE
    Using the example in DBIx::Class::Manual::ExampleSchema as a basis
    replace the DB::Main with the following code:

      package DB::Main;

      use base qw/DBIx::Class::Schema::Loader/;

      __PACKAGE__->loader_options(
          relationships => 1,
          debug         => 1,
      );
      __PACKAGE__->connection('dbi:SQLite:example.db');

      1;

    and remove the Main directory tree (optional). Every thing else should
    work the same

DEPRECATED METHODS
    You don't need to read anything in this section unless you're upgrading
    code that was written against pre-0.03 versions of this module. This
    version is intended to be backwards-compatible with pre-0.03 code, but
    will issue warnings about your usage of deprecated features/methods.

  load_from_connection
    This deprecated method is now roughly an alias for "loader_options".

    In the past it was a common idiom to invoke this method after defining a
    connection on the schema class. That usage is now deprecated. The
    correct way to do things from now forward is to always do
    "loader_options" on the class before "connect" or "connection" is
    invoked on the class or any derived object.

    This method *will* dissappear in a future version.

    For now, using this method will invoke the legacy behavior for backwards
    compatibility, and merely emit a warning about upgrading your code.

    It also reverts the default inflection scheme to use Lingua::EN::Inflect
    just like pre-0.03 versions of this module did.

    You can force these legacy inflections with the option
    "legacy_default_inflections", even after switch over to the preferred
    "loader_options" way of doing things.

    See the source of this method for more details.

  loader
    This is an accessor in the generated Schema class for accessing the
    DBIx::Class::Schema::Loader::Base -based loader object that was used
    during construction. See the DBIx::Class::Schema::Loader::Base docs for
    more information on the available loader methods there.

    This accessor is deprecated. Do not use it. Anything you can get from
    "loader", you can get via the normal DBIx::Class::Schema methods, and
    your code will be more robust and forward-thinking for doing so.

    If you're already using "loader" in your code, make an effort to get rid
    of it. If you think you've found a situation where it is neccesary, let
    me know and we'll see what we can do to remedy that situation.

    In some future version, this accessor *will* disappear. It was
    apparently quite a design/API mistake to ever have exposed it to
    user-land in the first place, all things considered.

KNOWN ISSUES
  Multiple Database Schemas
    Currently the loader is limited to working within a single schema (using
    the database vendors' definition of "schema"). If you have a
    multi-schema database with inter-schema relationships (which is easy to
    do in Postgres or DB2 for instance), you only get to automatically load
    the tables of one schema, and any relationships to tables in other
    schemas will be silently ignored.

    At some point in the future, an intelligent way around this might be
    devised, probably by allowing the "db_schema" option to be an arrayref
    of schemas to load, or perhaps even offering schema constraint/exclusion
    options just like the table ones.

    In "normal" DBIx::Class::Schema usage, manually-defined source classes
    and relationships have no problems crossing vendor schemas.

AUTHOR
    Brandon Black, "blblack@gmail.com"

    Based on DBIx::Class::Loader by Sebastian Riedel

    Based upon the work of IKEBE Tomohiro

THANK YOU
    Adam Anderson, Andy Grundman, Autrijus Tang, Dan Kubb, David Naughton,
    Randal Schwartz, Simon Flack, Matt S Trout, everyone on #dbix-class, and
    all the others who've helped.

LICENSE
    This library is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

SEE ALSO
    DBIx::Class, DBIx::Class::Manual::ExampleSchema

